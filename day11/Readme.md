## 오전 9:12 2023-05-17

# [접근제어자]

public
private ...

[ 로그 ]

기록
하나의 코드로 여러 개발자가 동시에 개발(작업)
 : 프로젝트 완성시 기여도 측정
 : 오류 발생시 어떤 액션+어떤 기능에서 발생했는지 기록
=> 메서드 위주로 기록
=> 단순 연산자는 기록이 대부분 남지 않는다

따라서 기본 연산으로 데이터 탈취시
로그에 남지 않아서 위험

>>>>접근하지 못하게 할것

private 을 설정한 변수에 접근시도시 에러
자동완성 또한 뜨지 않는다

자바는 public 일반적으로 디폴트
> 단순 연산자로 외부로부터의 접근을 막고 싶다

private
해당 클래스 내부에서만 접근 가능
외부접근 불가
this.name 사용 가능

진짜 변경이 필요할때
private된 멤버변수에 접근 가능하도록 하는 메서드를 추가
setter: 멤버변수에 값을 설정
getter: 멤버변수에 값을 받아옴

모든 멤버변수에게는 private 설정해야함

+접근 필요시 getter setter 설정
generate getter setter 활용

멤버변수에 접근한다는 사실 자체는 변함없지만
메서드를 사용하여 로그에 남는다는 차이가 있다
(외부에서 직접적으로 멤버변수의 값을 변경할 수는 없으나 getter setter를 인지하여 값을 바꿀수있음)

"캡슐화"

포켓몬 자체의 객체는 없는 것 아닌가???
피카츄와 파이리만 객체 있으면 되는 것 아닌가??? >>> 사실 맞음
객체화 하는 것이 목표가 아닌 설계 하는 것이 목표였던 "클래스"
클래스들의 기준이 되는 것이 목표
>>> 추상클래스

[ 추상클래스 ]
1. 객체화(인스턴스화) 불가
2. 추상 메서드를 가질 수 있다
3. 생성자를 가질 수는 있지만 new를 하지 못한다(객체화 불가)


오버라이딩 강제 : 추상 메서드 > 중괄호를 가질 수 없다 {바디를 가질 수 없다}
	=> 강제 ? == 좋음
	=> 안한다 => 1. 구현 강제 2. 상속 받은 클래스도 abstract



class Pokemon 포켓몬
String name 이름
int win 이긴횟수
void hello() 울음소리
boolean game() 게임
	: pokemonA.game(pokemonB)
	둘다 홀홀이면 작은값 XOR
	둘다 짝짝이면 큰값
	다르면 홀수가 이김

1. abstract일까?
	1) 객체 필요함?
	2) 추상 메서드 있음? == 오버라이딩 강제해야할 메서드가 있나?	
			== 재정의 해야하는 메서드가 있나?
2. 멤버변수 생성
	1) private
	2) getter setter

3. 생성자

4. 메서드
	1) 오버라이딩 강제 해야하나?
	2) 기능을 보고 인풋과 아웃풋을 생각하여 메서드 시그니차 작성




바로 자식 클래스를 만든 직후 오류 2가지
1. 추상메서드를 구현하지 않음
> 나도 추상클래스로 바꾼다 or 추상메소드 오버라이딩 한다
2. super() 호출하는 중인데 부모에 기본생성자가 없음
> 부모 클래스에 기본 생성자 만들기 or 부모 클래스의 다른 생성자 사용
		:::무조건 2번째(설계)

-중요한 요소-
생성자 컨트롤
오버라이딩
인자로 객체

메인이 아닌 게임 메서드내에서 this.win 대신 this.setWin(this.getWin()+1); 해도 되나요
> 되는데 클래스 내부라서 굳이 그렇게 할 필요가 없다

==================================================================================================

[ 실습 ]
class Player
   최대 3마리의 포켓몬을 소유할수있다.
   Player 생성시 최초 소지 포켓몬은 무조건 피카츄이다.
   final static int maxIndex=3;
   int preIndex; // 1
   Pokemon[] data; // new Pokemon[maxIndex]
   // data[0]=new 피카츄();
   void play()
      // data에 저장된 포켓몬을 랜덤으로 2마리 선택하여 게임을 진행
      // 단, 2마리의 포켓몬이 서로 같은 포켓몬이면 더이상 진행하지않음 [Object최상위클래스->equals() 오버라이딩]
               클래스 타입이 같으면 같은 포켓몬
      // 서로 다른 포켓몬이면 포켓몬.game()을 진행함
      // 이긴 포켓몬의 울음소리가 console에 출력됨
      // 포켓몬.hello()

class Pokemon [abstract]
   String name;
   int win; // 이긴횟수
   void hello() // 울음소리. 하위클래스에 따라 수행되는 기능이 다름에 유의 [오버라이딩 강제->추상메서드]
   boolean game(Pokemon pokemon)
      // win이 홀홀일때는 작은쪽이 이김
      // win이 짝짝일때는 큰쪽이 이김
      // win이 홀짝일때는 홀수가 이김
      // win이 동일하다면 주어(주체)가 이김
      // 이후 이긴쪽의 win이 1 증가



1. 포켓몬 추가
2. 가진 포켓몬 전체 출력
3. 게임시키기
4. 프로그램 종료

this. this()
객체 배열
super()
private +getter setter
상속일때 오버라이딩(메서드 재정의)

추상화
설계의 중요성
설계에 필요한 클래스(객체화 관심x)
abstract

캡슐화
private +getter setter

상속
extends

다형성
	A,B,C 객체가 동일한 기능을 수행했어도
	서로다른 효과가 나타나야할때
	=> 다형성 실현 필요

//this.data[num1] 가 equals를 수행하는 주체
    	  // 타입 == 포켓몬 피카츄,파이리,메타몽
    	  // 근데 이퀄은 포켓몬 한테 없는데 알아서 쓰고 있음
    	  // 부모.메서드 했어도 알아서 자식이 구현한 메서드가 실행되는 현상 == 동적바인딩
    	  // == 다형성이 실현되었다

